
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Interfacing with External C Code &#8212; 싸이선(Cython) 0.28a0 documentation</title>
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.28a0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="소스 파일과 컴파일" href="source_files_and_compilation_ko.html" />
    <link rel="prev" title="Sharing Declarations Between Cython Modules" href="sharing_declarations.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="source_files_and_compilation_ko.html" title="소스 파일과 컴파일"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="sharing_declarations.html" title="Sharing Declarations Between Cython Modules"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index_ko.html">싸이선(Cython) 0.28a0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index_ko.html" accesskey="U">사용자 가이드</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="interfacing-with-external-c-code">
<span id="external-c-code"></span><h1>Interfacing with External C Code<a class="headerlink" href="#interfacing-with-external-c-code" title="Permalink to this headline">¶</a></h1>
<p>One of the main uses of Cython is wrapping existing libraries of C code. This
is achieved by using external declarations to declare the C functions and
variables from the library that you want to use.</p>
<p>You can also use public declarations to make C functions and variables defined
in a Cython module available to external C code. The need for this is expected
to be less frequent, but you might want to do it, for example, if you are
<a class="reference external" href="http://www.freenet.org.nz/python/embeddingpyrex/">embedding Python</a> in another application as a scripting language. Just as a
Cython module can be used as a bridge to allow Python code to call C code, it
can also be used to allow C code to call Python code.</p>
<div class="section" id="external-declarations">
<h2>External declarations<a class="headerlink" href="#external-declarations" title="Permalink to this headline">¶</a></h2>
<p>By default, C functions and variables declared at the module level are local
to the module (i.e. they have the C static storage class). They can also be
declared extern to specify that they are defined elsewhere, for example,:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">extern</span> <span class="kt">int</span> <span class="nf">spam_counter</span>

<span class="k">cdef</span> <span class="kr">extern</span> <span class="kt">void</span> <span class="nf">order_spam</span><span class="p">(</span><span class="nb">int</span> <span class="n">tons</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="referencing-c-header-files">
<h3>Referencing C header files<a class="headerlink" href="#referencing-c-header-files" title="Permalink to this headline">¶</a></h3>
<p>When you use an extern definition on its own as in the examples above, Cython
includes a declaration for it in the generated C file. This can cause problems
if the declaration doesn’t exactly match the declaration that will be seen by
other C code. If you’re wrapping an existing C library, for example, it’s
important that the generated C code is compiled with exactly the same
declarations as the rest of the library.</p>
<p>To achieve this, you can tell Cython that the declarations are to be found in a
C header file, like this:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">extern</span> <span class="k">from</span> <span class="s">&quot;spam.h&quot;</span><span class="p">:</span>

    <span class="nb">int</span> <span class="n">spam_counter</span>

    <span class="n">void</span> <span class="n">order_spam</span><span class="p">(</span><span class="nb">int</span> <span class="n">tons</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">cdef</span> <span class="pre">extern</span></code> from clause does three things:</p>
<ol class="arabic simple">
<li>It directs Cython to place a <code class="docutils literal"><span class="pre">#include</span></code> statement for the named header file in
the generated C code.</li>
<li>It prevents Cython from generating any C code
for the declarations found in the associated block.</li>
<li>It treats all declarations within the block as though they started with
<code class="docutils literal"><span class="pre">cdef</span> <span class="pre">extern</span></code>.</li>
</ol>
<p>It’s important to understand that Cython does not itself read the C header
file, so you still need to provide Cython versions of any declarations from it
that you use. However, the Cython declarations don’t always have to exactly
match the C ones, and in some cases they shouldn’t or can’t. In particular:</p>
<ol class="arabic">
<li><p class="first">Leave out any platform-specific extensions to C declarations such as
<code class="docutils literal"><span class="pre">__declspec()</span></code>.</p>
</li>
<li><p class="first">If the header file declares a big struct and you only want to use a few
members, you only need to declare the members you’re interested in. Leaving
the rest out doesn’t do any harm, because the C compiler will use the full
definition from the header file.</p>
<p>In some cases, you might not need any of the struct’s members, in which
case you can just put pass in the body of the struct declaration, e.g.:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">extern</span> <span class="k">from</span> <span class="s">&quot;foo.h&quot;</span><span class="p">:</span>
    <span class="k">struct</span> <span class="nc">spam</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">you can only do this inside a <code class="docutils literal"><span class="pre">cdef</span> <span class="pre">extern</span> <span class="pre">from</span></code> block; struct
declarations anywhere else must be non-empty.</p>
</div>
</li>
<li><p class="first">If the header file uses <code class="docutils literal"><span class="pre">typedef</span></code> names such as <code class="xref c c-type docutils literal"><span class="pre">word</span></code> to refer
to platform-dependent flavours of numeric types, you will need a
corresponding <a class="reference internal" href="language_basics.html#ctypedef"><code class="xref std std-keyword docutils literal"><span class="pre">ctypedef</span></code></a> statement, but you don’t need to match
the type exactly, just use something of the right general kind (int, float,
etc). For example,:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">ctypedef</span> <span class="nb">int</span> <span class="n">word</span>
</pre></div>
</div>
<p>will work okay whatever the actual size of a <code class="xref c c-type docutils literal"><span class="pre">word</span></code> is (provided the header
file defines it correctly). Conversion to and from Python types, if any, will also
be used for this new type.</p>
</li>
<li><p class="first">If the header file uses macros to define constants, translate them into a
normal external variable declaration.  You can also declare them as an
<a class="reference internal" href="language_basics.html#enum"><code class="xref std std-keyword docutils literal"><span class="pre">enum</span></code></a> if they contain normal <code class="xref c c-type docutils literal"><span class="pre">int</span></code> values.  Note that
Cython considers <a class="reference internal" href="language_basics.html#enum"><code class="xref std std-keyword docutils literal"><span class="pre">enum</span></code></a> to be equivalent to <code class="xref c c-type docutils literal"><span class="pre">int</span></code>, so do
not do this for non-int values.</p>
</li>
<li><p class="first">If the header file defines a function using a macro, declare it as though
it were an ordinary function, with appropriate argument and result types.</p>
</li>
<li><p class="first">For archaic reasons C uses the keyword <code class="docutils literal"><span class="pre">void</span></code> to declare a function
taking no parameters. In Cython as in Python, simply declare such functions
as <code class="xref py py-meth docutils literal"><span class="pre">foo()</span></code>.</p>
</li>
</ol>
<p>A few more tricks and tips:</p>
<ul>
<li><p class="first">If you want to include a C header because it’s needed by another header, but
don’t want to use any declarations from it, put pass in the extern-from
block:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">extern</span> <span class="k">from</span> <span class="s">&quot;spam.h&quot;</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
</li>
<li><p class="first">If you want to include a system header, put angle brackets inside the quotes:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">extern</span> <span class="k">from</span> <span class="s">&quot;&lt;sysheader.h&gt;&quot;</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="first">If you want to include some external declarations, but don’t want to specify
a header file (because it’s included by some other header that you’ve
already included) you can put <code class="docutils literal"><span class="pre">*</span></code> in place of the header file name:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">extern</span> <span class="k">from</span> <span class="o">*</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="first">If a <code class="docutils literal"><span class="pre">cdef</span> <span class="pre">extern</span> <span class="pre">from</span> <span class="pre">&quot;inc.h&quot;</span></code> block is not empty and contains only
function or variable declarations (and no type declarations of any kind),
Cython will put the <code class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;inc.h&quot;</span></code> statement after all
declarations generated by Cython. This means that the included file
has access to the variables, functions, structures, … which are
declared by Cython.</p>
</li>
</ul>
</div>
<div class="section" id="implementing-functions-in-c">
<h3>Implementing functions in C<a class="headerlink" href="#implementing-functions-in-c" title="Permalink to this headline">¶</a></h3>
<p>When you want to call C code from a Cython module, usually that code
will be in some external library that you link your extension against.
However, you can also directly compile C (or C++) code as part of your
Cython module. In the <code class="docutils literal"><span class="pre">.pyx</span></code> file, you can put something like:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">extern</span> <span class="k">from</span> <span class="s">&quot;spam.c&quot;</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">order_spam</span><span class="p">(</span><span class="nb">int</span> <span class="n">tons</span><span class="p">)</span>
</pre></div>
</div>
<p>Cython will assume that the function <code class="docutils literal"><span class="pre">order_spam()</span></code> is defined in the
file <code class="docutils literal"><span class="pre">spam.c</span></code>. If you also want to cimport this function from another
module, it must be declared (not extern!) in the <code class="docutils literal"><span class="pre">.pxd</span></code> file:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kt">void</span> <span class="nf">order_spam</span><span class="p">(</span><span class="nb">int</span> <span class="n">tons</span><span class="p">)</span>
</pre></div>
</div>
<p>For this to work, the signature of <code class="docutils literal"><span class="pre">order_spam()</span></code> in <code class="docutils literal"><span class="pre">spam.c</span></code> must
match the signature that Cython uses, in particular the function must
be static:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">order_spam</span><span class="p">(</span><span class="kt">int</span> <span class="n">tons</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Ordered %i tons of spam!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tons</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="styles-of-struct-union-and-enum-declaration">
<span id="struct-union-enum-styles"></span><h3>Styles of struct, union and enum declaration<a class="headerlink" href="#styles-of-struct-union-and-enum-declaration" title="Permalink to this headline">¶</a></h3>
<p>There are two main ways that structs, unions and enums can be declared in C
header files: using a tag name, or using a typedef. There are also some
variations based on various combinations of these.</p>
<p>It’s important to make the Cython declarations match the style used in the
header file, so that Cython can emit the right sort of references to the type
in the code it generates. To make this possible, Cython provides two different
syntaxes for declaring a struct, union or enum type. The style introduced
above corresponds to the use of a tag name. To get the other style, you prefix
the declaration with <a class="reference internal" href="language_basics.html#ctypedef"><code class="xref std std-keyword docutils literal"><span class="pre">ctypedef</span></code></a>, as illustrated below.</p>
<p>The following table shows the various possible styles that can be found in a
header file, and the corresponding Cython declaration that you should put in
the <code class="docutils literal"><span class="pre">cdef</span> <span class="pre">extern</span></code> from block. Struct declarations are used as an example; the
same applies equally to union and enum declarations.</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="32%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">C code</th>
<th class="head">Possibilities for corresponding Cython Code</th>
<th class="head">Comments</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><div class="first last highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
</td>
<td><div class="first last highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="k">struct</span> <span class="nf">Foo</span><span class="p">:</span>
  <span class="o">...</span>
</pre></div>
</div>
</td>
<td>Cython will refer to the as <code class="docutils literal"><span class="pre">struct</span> <span class="pre">Foo</span></code> in the generated C code.</td>
</tr>
<tr class="row-odd"><td><div class="first last highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="n">Foo</span><span class="p">;</span>
</pre></div>
</div>
</td>
<td><div class="first last highlight-cython"><div class="highlight"><pre><span></span><span class="k">ctypedef</span> <span class="k">struct</span> <span class="nc">Foo</span><span class="p">:</span>
  <span class="o">...</span>
</pre></div>
</div>
</td>
<td>Cython will refer to the type simply as <code class="docutils literal"><span class="pre">Foo</span></code> in
the generated C code.</td>
</tr>
<tr class="row-even"><td><div class="first last highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="n">Foo</span><span class="p">;</span>
</pre></div>
</div>
</td>
<td><div class="first highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="k">struct</span> <span class="nf">foo</span><span class="p">:</span>
  <span class="o">...</span>
<span class="k">ctypedef</span> <span class="n">foo</span> <span class="n">Foo</span> <span class="c">#optional</span>
</pre></div>
</div>
<p>or:</p>
<div class="last highlight-cython"><div class="highlight"><pre><span></span><span class="k">ctypedef</span> <span class="k">struct</span> <span class="nc">Foo</span><span class="p">:</span>
  <span class="o">...</span>
</pre></div>
</div>
</td>
<td>If the C header uses both a tag and a typedef with <em>different</em>
names, you can use either form of declaration in Cython
(although if you need to forward reference the type,
you’ll have to use the first form).</td>
</tr>
<tr class="row-odd"><td><div class="first last highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="n">Foo</span><span class="p">;</span>
</pre></div>
</div>
</td>
<td><div class="first last highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="k">struct</span> <span class="nf">Foo</span><span class="p">:</span>
  <span class="o">...</span>
</pre></div>
</div>
</td>
<td>If the header uses the <em>same</em> name for the tag and typedef, you
won’t be able to include a <a class="reference internal" href="language_basics.html#ctypedef"><code class="xref std std-keyword docutils literal"><span class="pre">ctypedef</span></code></a> for it – but then,
it’s not necessary.</td>
</tr>
</tbody>
</table>
<p>Note that in all the cases below, you refer to the type in Cython code simply
as <code class="xref c c-type docutils literal"><span class="pre">Foo</span></code>, not <code class="docutils literal"><span class="pre">struct</span> <span class="pre">Foo</span></code>.</p>
</div>
<div class="section" id="accessing-python-c-api-routines">
<h3>Accessing Python/C API routines<a class="headerlink" href="#accessing-python-c-api-routines" title="Permalink to this headline">¶</a></h3>
<p>One particular use of the <code class="docutils literal"><span class="pre">cdef</span> <span class="pre">extern</span> <span class="pre">from</span></code> statement is for gaining access to
routines in the Python/C API. For example,:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">extern</span> <span class="k">from</span> <span class="s">&quot;Python.h&quot;</span><span class="p">:</span>

    <span class="nb">object</span> <span class="n">PyString_FromStringAndSize</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="nb">len</span><span class="p">)</span>
</pre></div>
</div>
<p>will allow you to create Python strings containing null bytes.</p>
</div>
<div class="section" id="special-types">
<h3>Special Types<a class="headerlink" href="#special-types" title="Permalink to this headline">¶</a></h3>
<p>Cython predefines the name <code class="docutils literal"><span class="pre">Py_ssize_t</span></code> for use with Python/C API routines. To
make your extensions compatible with 64-bit systems, you should always use
this type where it is specified in the documentation of Python/C API routines.</p>
</div>
<div class="section" id="windows-calling-conventions">
<h3>Windows Calling Conventions<a class="headerlink" href="#windows-calling-conventions" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">__stdcall</span></code> and <code class="docutils literal"><span class="pre">__cdecl</span></code> calling convention specifiers can be used in
Cython, with the same syntax as used by C compilers on Windows, for example,:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">extern</span> <span class="kt">int</span> <span class="kt">__stdcall</span> <span class="nf">FrobnicateWindow</span><span class="p">(</span><span class="nb">long</span> <span class="n">handle</span><span class="p">)</span>

<span class="k">cdef</span> <span class="nf">void</span> <span class="p">(</span><span class="n">__stdcall</span> <span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">__stdcall</span></code> is used, the function is only considered compatible with
other <code class="docutils literal"><span class="pre">__stdcall</span></code> functions of the same signature.</p>
</div>
<div class="section" id="resolving-naming-conflicts-c-name-specifications">
<span id="resolve-conflicts"></span><h3>Resolving naming conflicts - C name specifications<a class="headerlink" href="#resolving-naming-conflicts-c-name-specifications" title="Permalink to this headline">¶</a></h3>
<p>Each Cython module has a single module-level namespace for both Python and C
names.  This can be inconvenient if you want to wrap some external C functions
and provide the Python user with Python functions of the same names.</p>
<p>Cython provides a couple of different ways of solving this problem.  The best
way, especially if you have many C functions to wrap, is to put the extern
C function declarations into a <code class="docutils literal"><span class="pre">.pxd</span></code> file and thus a different namespace,
using the facilities described in <a class="reference internal" href="sharing_declarations.html#sharing-declarations"><span class="std std-ref">sharing declarations between Cython
modules</span></a>.  Writing them into a <code class="docutils literal"><span class="pre">.pxd</span></code> file allows
their reuse across modules, avoids naming collisions in the normal Python way
and even makes it easy to rename them on cimport.  For example, if your
<code class="docutils literal"><span class="pre">decl.pxd</span></code> file declared a C function <code class="docutils literal"><span class="pre">eject_tomato</span></code>:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">extern</span> <span class="k">from</span> <span class="s">&quot;myheader.h&quot;</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">eject_tomato</span><span class="p">(</span><span class="nb">float</span> <span class="n">speed</span><span class="p">)</span>
</pre></div>
</div>
<p>then you can cimport and wrap it in a <code class="docutils literal"><span class="pre">.pyx</span></code> file as follows:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">from</span> <span class="nn">decl</span> <span class="k">cimport</span> <span class="n">eject_tomato</span> <span class="k">as</span> <span class="n">c_eject_tomato</span>

<span class="k">def</span> <span class="nf">eject_tomato</span><span class="p">(</span><span class="n">speed</span><span class="p">):</span>
    <span class="n">c_eject_tomato</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
</pre></div>
</div>
<p>or simply cimport the <code class="docutils literal"><span class="pre">.pxd</span></code> file and use it as prefix:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cimport</span> <span class="nn">decl</span>

<span class="k">def</span> <span class="nf">eject_tomato</span><span class="p">(</span><span class="n">speed</span><span class="p">):</span>
    <span class="n">decl</span><span class="o">.</span><span class="n">eject_tomato</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that this has no runtime lookup overhead, as it would in Python.
Cython resolves the names in the <code class="docutils literal"><span class="pre">.pxd</span></code> file at compile time.</p>
<p>For special cases where namespacing or renaming on import is not enough,
e.g. when a name in C conflicts with a Python keyword, you can use a C name
specification to give different Cython and C names to the C function at
declaration time.  Suppose, for example, that you want to wrap an external
C function called <code class="xref py py-func docutils literal"><span class="pre">yield()</span></code>.  If you declare it as:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">extern</span> <span class="k">from</span> <span class="s">&quot;myheader.h&quot;</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">c_yield</span> <span class="s">&quot;yield&quot;</span> <span class="p">(</span><span class="nb">float</span> <span class="n">speed</span><span class="p">)</span>
</pre></div>
</div>
<p>then its Cython visible name will be <code class="docutils literal"><span class="pre">c_yield</span></code>, whereas its name in C
will be <code class="docutils literal"><span class="pre">yield</span></code>.  You can then wrap it with:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">call_yield</span><span class="p">(</span><span class="n">speed</span><span class="p">):</span>
    <span class="n">c_yield</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
</pre></div>
</div>
<p>As for functions, C names can be specified for variables, structs, unions,
enums, struct and union members, and enum values.  For example:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">extern</span> <span class="kt">int</span> <span class="kt">one</span> <span class="s">&quot;eins&quot;</span><span class="p">,</span> <span class="n">two</span> <span class="s">&quot;zwei&quot;</span>
<span class="k">cdef</span> <span class="kr">extern</span> <span class="kt">float</span> <span class="kt">three</span> <span class="s">&quot;drei&quot;</span>

<span class="k">cdef</span> <span class="k">struct</span> <span class="kt">spam</span> <span class="s">&quot;SPAM&quot;</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">i</span> <span class="s">&quot;eye&quot;</span>

<span class="k">cdef</span> <span class="k">enum</span> <span class="kt">surprise</span> <span class="s">&quot;inquisition&quot;</span><span class="p">:</span>
    <span class="n">first</span> <span class="s">&quot;alpha&quot;</span>
    <span class="n">second</span> <span class="s">&quot;beta&quot;</span> <span class="o">=</span> <span class="mf">3</span>
</pre></div>
</div>
<p>Note that Cython will not do any validation or name mangling on the string
you provide.  It will inject the bare text into the C code unmodified, so you
are entirely on your own with this feature.  If you want to declare a name
<code class="docutils literal"><span class="pre">xyz</span></code> and have Cython inject the text “make the C compiler fail here” into
the C file for it, you can do this using a C name declaration.  Consider this
an advanced feature, only for the rare cases where everything else fails.</p>
</div>
</div>
<div class="section" id="using-cython-declarations-from-c">
<h2>Using Cython Declarations from C<a class="headerlink" href="#using-cython-declarations-from-c" title="Permalink to this headline">¶</a></h2>
<p>Cython provides two methods for making C declarations from a Cython module
available for use by external C code—public declarations and C API
declarations.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You do not need to use either of these to make declarations from one
Cython module available to another Cython module – you should use the
<a class="reference internal" href="sharing_declarations.html#cimport"><code class="xref std std-keyword docutils literal"><span class="pre">cimport</span></code></a> statement for that. Sharing Declarations Between Cython Modules.</p>
</div>
<div class="section" id="public-declarations">
<h3>Public Declarations<a class="headerlink" href="#public-declarations" title="Permalink to this headline">¶</a></h3>
<p>You can make C types, variables and functions defined in a Cython module
accessible to C code that is linked together with the Cython-generated C file,
by declaring them with the public keyword:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">public</span> <span class="k">struct</span> <span class="nf">Bunny</span><span class="p">:</span> <span class="c"># public type declaration</span>
    <span class="nb">int</span> <span class="n">vorpalness</span>

<span class="k">cdef</span> <span class="kr">public</span> <span class="kt">int</span> <span class="nf">spam</span> <span class="c"># public variable declaration</span>

<span class="k">cdef</span> <span class="kr">public</span> <span class="kt">void</span> <span class="nf">grail</span><span class="p">(</span><span class="n">Bunny</span> <span class="o">*</span><span class="p">)</span> <span class="c"># public function declaration</span>
</pre></div>
</div>
<p>If there are any public declarations in a Cython module, a header file called
<code class="file docutils literal"><span class="pre">modulename.h</span></code> file is generated containing equivalent C declarations for
inclusion in other C code.</p>
<p>A typical use case for this is building an extension module from multiple
C sources, one of them being Cython generated (i.e. with something like
<code class="docutils literal"><span class="pre">Extension(&quot;grail&quot;,</span> <span class="pre">sources=[&quot;grail.pyx&quot;,</span> <span class="pre">&quot;grail_helper.c&quot;])</span></code> in <code class="docutils literal"><span class="pre">setup.py</span></code>.
In this case, the file <code class="docutils literal"><span class="pre">grail_helper.c</span></code> just needs to add
<code class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;grail.h&quot;</span></code> in order to access the public Cython variables.</p>
<p>A more advanced use case is embedding Python in C using Cython.
In this case, make sure to call Py_Initialize() and Py_Finalize().
For example, in the following snippet that includes <code class="file docutils literal"><span class="pre">grail.h</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;grail.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Py_Initialize</span><span class="p">();</span>
    <span class="n">initgrail</span><span class="p">();</span>  <span class="cm">/* Python 2.x only ! */</span>
    <span class="n">Bunny</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">grail</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="n">Py_Finalize</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This C code can then be built together with the Cython-generated C code
in a single program (or library).</p>
<p>In Python 3.x, calling the module init function directly should be avoided.  Instead,
use the <a class="reference external" href="https://docs.python.org/3/c-api/import.html#c._inittab">inittab mechanism</a>
to link Cython modules into a single shared library or program.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">err</span> <span class="o">=</span> <span class="n">PyImport_AppendInittab</span><span class="p">(</span><span class="s">&quot;grail&quot;</span><span class="p">,</span> <span class="n">PyInit_grail</span><span class="p">);</span>
<span class="n">Py_Initialize</span><span class="p">();</span>
<span class="n">grail_module</span> <span class="o">=</span> <span class="n">PyImport_ImportModule</span><span class="p">(</span><span class="s">&quot;grail&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>If the Cython module resides within a package, then the name of the <code class="docutils literal"><span class="pre">.h</span></code>
file consists of the full dotted name of the module, e.g. a module called
<code class="xref py py-mod docutils literal"><span class="pre">foo.spam</span></code> would have a header file called <code class="file docutils literal"><span class="pre">foo.spam.h</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On some operating systems like Linux, it is also possible to first
build the Cython extension in the usual way and then link against
the resulting <code class="docutils literal"><span class="pre">.so</span></code> file like a dynamic library.
Beware that this is not portable, so it should be avoided.</p>
</div>
</div>
<div class="section" id="c-api-declarations">
<span id="api"></span><h3>C API Declarations<a class="headerlink" href="#c-api-declarations" title="Permalink to this headline">¶</a></h3>
<p>The other way of making declarations available to C code is to declare them
with the <a class="reference internal" href="#api"><code class="xref std std-keyword docutils literal"><span class="pre">api</span></code></a> keyword. You can use this keyword with C functions and
extension types. A header file called <code class="file docutils literal"><span class="pre">modulename_api.h</span></code> is produced
containing declarations of the functions and extension types, and a function
called <code class="xref py py-func docutils literal"><span class="pre">import_modulename()</span></code>.</p>
<p>C code wanting to use these functions or extension types needs to include the
header and call the <code class="xref py py-func docutils literal"><span class="pre">import_modulename()</span></code> function. The other functions
can then be called and the extension types used as usual.</p>
<p>If the C code wanting to use these functions is part of more than one shared
library or executable, then <code class="xref py py-func docutils literal"><span class="pre">import_modulename()</span></code> function needs to be
called in each of the shared libraries which use these functions. If you
crash with a segmentation fault (SIGSEGV on linux) when calling into one of
these api calls, this is likely an indication that the shared library which
contains the api call which is generating the segmentation fault does not call
the <code class="xref py py-func docutils literal"><span class="pre">import_modulename()</span></code> function before the api call which crashes.</p>
<p>Any public C type or extension type declarations in the Cython module are also
made available when you include <code class="file docutils literal"><span class="pre">modulename_api.h</span></code>.:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c"># delorean.pyx</span>
<span class="k">cdef</span> <span class="kr">public</span> <span class="k">struct</span> <span class="nf">Vehicle</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">speed</span>
    <span class="nb">float</span> <span class="n">power</span>

<span class="k">cdef</span> <span class="kr">api</span> <span class="kt">void</span> <span class="nf">activate</span><span class="p">(</span><span class="n">Vehicle</span> <span class="o">*</span><span class="n">v</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">speed</span> <span class="o">&gt;=</span> <span class="mf">88</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">power</span> <span class="o">&gt;=</span> <span class="mf">1.21</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;Time travel achieved&quot;</span>
</pre></div>
</div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp"># marty.c</span>
<span class="cp">#include</span> <span class="cpf">&quot;delorean_api.h&quot;</span><span class="cp"></span>

<span class="n">Vehicle</span> <span class="n">car</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">Py_Initialize</span><span class="p">();</span>
    <span class="n">import_delorean</span><span class="p">();</span>
    <span class="n">car</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">car</span><span class="p">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">atof</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="n">activate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">car</span><span class="p">);</span>
    <span class="n">Py_Finalize</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Any types defined in the Cython module that are used as argument or
return types of the exported functions will need to be declared public,
otherwise they won’t be included in the generated header file, and you will
get errors when you try to compile a C file that uses the header.</p>
</div>
<p>Using the <a class="reference internal" href="#api"><code class="xref std std-keyword docutils literal"><span class="pre">api</span></code></a> method does not require the C code using the
declarations to be linked with the extension module in any way, as the Python
import machinery is used to make the connection dynamically. However, only
functions can be accessed this way, not variables. Note also that for the
module import mechanism to be set up correctly, the user must call
Py_Initialize() and Py_Finalize(); if you experience a segmentation fault in
the call to <code class="xref py py-func docutils literal"><span class="pre">import_modulename()</span></code>, it is likely that this wasn’t done.</p>
<p>You can use both <code class="xref std std-keyword docutils literal"><span class="pre">public</span></code> and <a class="reference internal" href="#api"><code class="xref std std-keyword docutils literal"><span class="pre">api</span></code></a> on the same function to
make it available by both methods, e.g.:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">public</span> <span class="kr">api</span> <span class="kt">void</span> <span class="nf">belt_and_braces</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>However, note that you should include either <code class="file docutils literal"><span class="pre">modulename.h</span></code> or
<code class="file docutils literal"><span class="pre">modulename_api.h</span></code> in a given C file, not both, otherwise you may get
conflicting dual definitions.</p>
<p>If the Cython module resides within a package, then:</p>
<ul class="simple">
<li>The name of the header file contains of the full dotted name of the module.</li>
<li>The name of the importing function contains the full name with dots replaced
by double underscores.</li>
</ul>
<p>E.g. a module called <code class="xref py py-mod docutils literal"><span class="pre">foo.spam</span></code> would have an API header file called
<code class="file docutils literal"><span class="pre">foo.spam_api.h</span></code> and an importing function called
<code class="xref py py-func docutils literal"><span class="pre">import_foo__spam()</span></code>.</p>
</div>
<div class="section" id="multiple-public-and-api-declarations">
<h3>Multiple public and API declarations<a class="headerlink" href="#multiple-public-and-api-declarations" title="Permalink to this headline">¶</a></h3>
<p>You can declare a whole group of items as <code class="xref std std-keyword docutils literal"><span class="pre">public</span></code> and/or
<a class="reference internal" href="#api"><code class="xref std std-keyword docutils literal"><span class="pre">api</span></code></a> all at once by enclosing them in a <a class="reference internal" href="../reference/language_basics.html#cdef"><code class="xref std std-keyword docutils literal"><span class="pre">cdef</span></code></a> block, for
example,:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kr">public</span> <span class="kr">api</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">order_spam</span><span class="p">(</span><span class="nb">int</span> <span class="n">tons</span><span class="p">)</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">get_lunch</span><span class="p">(</span><span class="nb">float</span> <span class="n">tomato_size</span><span class="p">)</span>
</pre></div>
</div>
<p>This can be a useful thing to do in a <code class="docutils literal"><span class="pre">.pxd</span></code> file (see
<a class="reference internal" href="sharing_declarations.html#sharing-declarations"><span class="std std-ref">Sharing Declarations Between Cython Modules</span></a>) to make the module’s public interface
available by all three methods.</p>
</div>
<div class="section" id="acquiring-and-releasing-the-gil">
<h3>Acquiring and Releasing the GIL<a class="headerlink" href="#acquiring-and-releasing-the-gil" title="Permalink to this headline">¶</a></h3>
<p>Cython provides facilities for acquiring and releasing the
<a class="reference external" href="http://docs.python.org/dev/glossary.html#term-global-interpreter-lock">Global Interpreter Lock (GIL)</a>.
This may be useful when calling from multi-threaded code into
(external C) code that may block, or when wanting to use Python
from a (native) C thread callback.  Releasing the GIL should
obviously only be done for thread-safe code or for code that
uses other means of protection against race conditions and
concurrency issues.</p>
<p>Note that acquiring the GIL is a blocking thread-synchronising
operation, and therefore potentially costly.  It might not be
worth releasing the GIL for minor calculations.  Usually, I/O
operations and substantial computations in parallel code will
benefit from it.</p>
<div class="section" id="releasing-the-gil">
<span id="nogil"></span><h4>Releasing the GIL<a class="headerlink" href="#releasing-the-gil" title="Permalink to this headline">¶</a></h4>
<p>You can release the GIL around a section of code using the
<code class="docutils literal"><span class="pre">with</span> <span class="pre">nogil</span></code> statement:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">to</span> <span class="n">be</span> <span class="n">executed</span> <span class="k">with</span> <span class="n">the</span> <span class="n">GIL</span> <span class="n">released</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Code in the body of the with-statement must not raise exceptions or
manipulate Python objects in any way, and must not call anything that
manipulates Python objects without first re-acquiring the GIL.  Cython
validates these operations at compile time, but cannot look into
external C functions, for example.  They must be correctly declared
as requiring or not requiring the GIL (see below) in order to make
Cython’s checks effective.</p>
</div>
<div class="section" id="acquiring-the-gil">
<span id="gil"></span><h4>Acquiring the GIL<a class="headerlink" href="#acquiring-the-gil" title="Permalink to this headline">¶</a></h4>
<p>A C function that is to be used as a callback from C code that is executed
without the GIL needs to acquire the GIL before it can manipulate Python
objects. This can be done by specifying <code class="docutils literal"><span class="pre">with</span> <span class="pre">gil</span></code> in the function
header:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kt">void</span> <span class="nf">my_callback</span><span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="k">with</span> <span class="k">gil</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>If the callback may be called from another non-Python thread,
care must be taken to initialize the GIL first, through a call to
<a class="reference external" href="http://docs.python.org/dev/c-api/init.html#PyEval_InitThreads">PyEval_InitThreads()</a>.
If you’re already using  <a class="reference internal" href="parallelism.html#parallel"><span class="std std-ref">cython.parallel</span></a> in your module, this will already have been taken care of.</p>
<p>The GIL may also be acquired through the <code class="docutils literal"><span class="pre">with</span> <span class="pre">gil</span></code> statement:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="k">gil</span><span class="p">:</span>
    <span class="o">&lt;</span><span class="n">execute</span> <span class="n">this</span> <span class="n">block</span> <span class="k">with</span> <span class="n">the</span> <span class="n">GIL</span> <span class="n">acquired</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="declaring-a-function-as-callable-without-the-gil">
<h3>Declaring a function as callable without the GIL<a class="headerlink" href="#declaring-a-function-as-callable-without-the-gil" title="Permalink to this headline">¶</a></h3>
<p>You can specify <a class="reference internal" href="#nogil"><code class="xref std std-keyword docutils literal"><span class="pre">nogil</span></code></a> in a C function header or function type to
declare that it is safe to call without the GIL.:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kt">void</span> <span class="nf">my_gil_free_func</span><span class="p">(</span><span class="nb">int</span> <span class="n">spam</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>When you implement such a function in Cython, it cannot have any Python
arguments or Python object return type.  Furthermore, any operation
that involves Python objects (including calling Python functions) must
explicitly acquire the GIL first, e.g. by using a <code class="docutils literal"><span class="pre">with</span> <span class="pre">gil</span></code> block
or by calling a function that has been defined <code class="docutils literal"><span class="pre">with</span> <span class="pre">gil</span></code>.  These
restrictions are checked by Cython and you will get a compile error
if it finds any Python interaction inside of a <code class="docutils literal"><span class="pre">nogil</span></code> code section.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal"><span class="pre">nogil</span></code> function annotation declares that it is safe
to call the function without the GIL.  It is perfectly allowed
to execute it while holding the GIL.  The function does not in
itself release the GIL if it is held by the caller.</p>
</div>
<p>Declaring a function <code class="docutils literal"><span class="pre">with</span> <span class="pre">gil</span></code> (i.e. as acquiring the GIL on entry) also
implicitly makes its signature <a class="reference internal" href="#nogil"><code class="xref std std-keyword docutils literal"><span class="pre">nogil</span></code></a>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index_ko.html">
              <img class="logo" src="../../_static/cythonlogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index_ko.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Interfacing with External C Code</a><ul>
<li><a class="reference internal" href="#external-declarations">External declarations</a><ul>
<li><a class="reference internal" href="#referencing-c-header-files">Referencing C header files</a></li>
<li><a class="reference internal" href="#implementing-functions-in-c">Implementing functions in C</a></li>
<li><a class="reference internal" href="#styles-of-struct-union-and-enum-declaration">Styles of struct, union and enum declaration</a></li>
<li><a class="reference internal" href="#accessing-python-c-api-routines">Accessing Python/C API routines</a></li>
<li><a class="reference internal" href="#special-types">Special Types</a></li>
<li><a class="reference internal" href="#windows-calling-conventions">Windows Calling Conventions</a></li>
<li><a class="reference internal" href="#resolving-naming-conflicts-c-name-specifications">Resolving naming conflicts - C name specifications</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-cython-declarations-from-c">Using Cython Declarations from C</a><ul>
<li><a class="reference internal" href="#public-declarations">Public Declarations</a></li>
<li><a class="reference internal" href="#c-api-declarations">C API Declarations</a></li>
<li><a class="reference internal" href="#multiple-public-and-api-declarations">Multiple public and API declarations</a></li>
<li><a class="reference internal" href="#acquiring-and-releasing-the-gil">Acquiring and Releasing the GIL</a><ul>
<li><a class="reference internal" href="#releasing-the-gil">Releasing the GIL</a></li>
<li><a class="reference internal" href="#acquiring-the-gil">Acquiring the GIL</a></li>
</ul>
</li>
<li><a class="reference internal" href="#declaring-a-function-as-callable-without-the-gil">Declaring a function as callable without the GIL</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="sharing_declarations.html"
                        title="previous chapter">Sharing Declarations Between Cython Modules</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="source_files_and_compilation_ko.html"
                        title="next chapter">소스 파일과 컴파일</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/src/userguide/external_C_code.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="source_files_and_compilation_ko.html" title="소스 파일과 컴파일"
             >next</a></li>
        <li class="right" >
          <a href="sharing_declarations.html" title="Sharing Declarations Between Cython Modules"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index_ko.html">싸이선(Cython) 0.28a0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index_ko.html" >사용자 가이드</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Stefan Behnel, Robert Bradshaw, Dag Sverre Seljebotn, Greg Ewing, William Stein, Gabriel Gellner, et al..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-6139100-3");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>