
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>프로파일링 &#8212; 싸이선(Cython) 0.28a0 documentation</title>
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.28a0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="유니코드와 문자열 전달" href="strings_ko.html" />
    <link rel="prev" title="주의사항" href="caveats_ko.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="strings_ko.html" title="유니코드와 문자열 전달"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="caveats_ko.html" title="주의사항"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index_ko.html">싸이선(Cython) 0.28a0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index_ko.html" accesskey="U">튜토리얼</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="profiling">
<span id="id1"></span><h1>프로파일링<a class="headerlink" href="#profiling" title="Permalink to this headline">¶</a></h1>
<p>This part describes the profiling abilities of Cython. If you are familiar
with profiling pure Python code, you can only read the first section
(<a class="reference internal" href="#profiling-basics"><span class="std std-ref">Cython Profiling Basics</span></a>). If you are not familiar with Python profiling you
should also read the tutorial (<a class="reference internal" href="#profiling-tutorial"><span class="std std-ref">Profiling Tutorial</span></a>) which takes you
through a complete example step by step.</p>
<div class="section" id="cython-profiling-basics">
<span id="profiling-basics"></span><h2>Cython Profiling Basics<a class="headerlink" href="#cython-profiling-basics" title="Permalink to this headline">¶</a></h2>
<p>Profiling in Cython is controlled by a compiler directive.
It can be set either for an entire file or on a per function basis
via a Cython decorator.</p>
<div class="section" id="enabling-profiling-for-a-complete-source-file">
<h3>Enabling profiling for a complete source file<a class="headerlink" href="#enabling-profiling-for-a-complete-source-file" title="Permalink to this headline">¶</a></h3>
<p>Profiling is enabled for a complete source file via a global directive to the
Cython compiler at the top of a file:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c"># cython: profile=True</span>
</pre></div>
</div>
<p>Note that profiling gives a slight overhead to each function call therefore making
your program a little slower (or a lot, if you call some small functions very
often).</p>
<p>Once enabled, your Cython code will behave just like Python code when called
from the cProfile module. This means you can just profile your Cython code
together with your Python code using the same tools as for Python code alone.</p>
</div>
<div class="section" id="disabling-profiling-function-wise">
<h3>Disabling profiling function wise<a class="headerlink" href="#disabling-profiling-function-wise" title="Permalink to this headline">¶</a></h3>
<p>If your profiling is messed up because of the call overhead to some small
functions that you rather do not want to see in your profile - either because
you plan to inline them anyway or because you are sure that you can’t make them
any faster - you can use a special decorator to disable profiling for one
function only:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cimport</span> <span class="nn">cython</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">profile</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_often_called_function</span><span class="p">():</span>
   <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="enabling-line-tracing">
<h3>Enabling line tracing<a class="headerlink" href="#enabling-line-tracing" title="Permalink to this headline">¶</a></h3>
<p>To get more detailed trace information (for tools that can make use of it),
you can enable line tracing:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c"># cython: linetrace=True</span>
</pre></div>
</div>
<p>This will also enable profiling support, so the above <code class="docutils literal"><span class="pre">profile=True</span></code> option
is not needed.  Line tracing is needed for coverage analysis, for example.</p>
<p>Note that even if line tracing is enabled via the compiler directive, it is
not used by default.  As the runtime slowdown can be substantial, it must
additionally be compiled in by the C compiler by setting the C macro definition
<code class="docutils literal"><span class="pre">CYTHON_TRACE=1</span></code>.  To include nogil functions in the trace, set
<code class="docutils literal"><span class="pre">CYTHON_TRACE_NOGIL=1</span></code> (which implies <code class="docutils literal"><span class="pre">CYTHON_TRACE=1</span></code>).  C macros can be
defined either in the extension definition of the <code class="docutils literal"><span class="pre">setup.py</span></code> script or by
setting the respective distutils options in the source file with the following
file header comment (if <code class="docutils literal"><span class="pre">cythonize()</span></code> is used for compilation):</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c"># distutils: define_macros=CYTHON_TRACE_NOGIL=1</span>
</pre></div>
</div>
</div>
<div class="section" id="enabling-coverage-analysis">
<h3>Enabling coverage analysis<a class="headerlink" href="#enabling-coverage-analysis" title="Permalink to this headline">¶</a></h3>
<p>Since Cython 0.23, line tracing (see above) also enables support for coverage
reporting with the <a class="reference external" href="http://nedbatchelder.com/code/coverage/">coverage.py</a> tool.
To make the coverage analysis understand Cython modules, you also need to enable
Cython’s coverage plugin in your <code class="docutils literal"><span class="pre">.coveragerc</span></code> file as follows:</p>
<div class="highlight-ini"><div class="highlight"><pre><span></span><span class="k">[run]</span>
<span class="na">plugins</span> <span class="o">=</span> <span class="s">Cython.Coverage</span>
</pre></div>
</div>
<p>With this plugin, your Cython source files should show up normally in the
coverage reports.</p>
<p>To include the coverage report in the Cython annotated HTML file, you need
to first run the coverage.py tool to generate an XML result file.  Pass
this file into the <code class="docutils literal"><span class="pre">cython</span></code> command as follows:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ cython  --annotate-coverage coverage.xml  package/mymodule.pyx
</pre></div>
</div>
<p>This will recompile the Cython module and generate one HTML output
file next to each Cython source file it processes, containing colour
markers for lines that were contained in the coverage report.</p>
</div>
</div>
<div class="section" id="profiling-tutorial">
<span id="id2"></span><h2>Profiling Tutorial<a class="headerlink" href="#profiling-tutorial" title="Permalink to this headline">¶</a></h2>
<p>This will be a complete tutorial, start to finish, of profiling Python code,
turning it into Cython code and keep profiling until it is fast enough.</p>
<p>As a toy example, we would like to evaluate the summation of the reciprocals of
squares up to a certain integer <img class="math" src="../../_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> for evaluating <img class="math" src="../../_images/math/c1bd4cb4e3647c6b2356b7ccf2f52aeffedd1b61.png" alt="\pi"/>. The
relation we want to use has been proven by Euler in 1735 and is known as the
<a class="reference external" href="http://en.wikipedia.org/wiki/Basel_problem">Basel problem</a>.</p>
<div class="math">
<p><img src="../../_images/math/3b0020ee03af7d7c23191a1be79c3859e13ba7fb.png" alt="\pi^2 = 6 \sum_{k=1}^{\infty} \frac{1}{k^2} =
6 \lim_{k \to \infty} \big( \frac{1}{1^2} +
      \frac{1}{2^2} + \dots + \frac{1}{k^2}  \big) \approx
6 \big( \frac{1}{1^2} + \frac{1}{2^2} + \dots + \frac{1}{n^2}  \big)"/></p>
</div><p>A simple Python code for evaluating the truncated sum looks like this:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c">#!/usr/bin/env python</span>
<span class="c"># encoding: utf-8</span>
<span class="c"># filename: calc_pi.py</span>

<span class="k">def</span> <span class="nf">recip_square</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="n">i</span><span class="o">**</span><span class="mf">2</span>

<span class="k">def</span> <span class="nf">approx_pi</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mf">10000000</span><span class="p">):</span>
    <span class="n">val</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mf">1</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">+=</span> <span class="n">recip_square</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">6</span> <span class="o">*</span> <span class="n">val</span><span class="p">)</span><span class="o">**.</span><span class="mf">5</span>
</pre></div>
</div>
<p>On my box, this needs approximately 4 seconds to run the function with the
default n. The higher we choose n, the better will be the approximation for
<img class="math" src="../../_images/math/c1bd4cb4e3647c6b2356b7ccf2f52aeffedd1b61.png" alt="\pi"/>. An experienced Python programmer will already see plenty of
places to optimize this code. But remember the golden rule of optimization:
Never optimize without having profiled. Let me repeat this: <strong>Never</strong> optimize
without having profiled your code. Your thoughts about which part of your
code takes too much time are wrong. At least, mine are always wrong. So let’s
write a short script to profile our code:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c">#!/usr/bin/env python</span>
<span class="c"># encoding: utf-8</span>
<span class="c"># filename: profile.py</span>

<span class="k">import</span> <span class="nn">pstats</span><span class="o">,</span> <span class="nn">cProfile</span>

<span class="k">import</span> <span class="nn">calc_pi</span>

<span class="n">cProfile</span><span class="o">.</span><span class="n">runctx</span><span class="p">(</span><span class="s">&quot;calc_pi.approx_pi()&quot;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="s">&quot;Profile.prof&quot;</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">pstats</span><span class="o">.</span><span class="n">Stats</span><span class="p">(</span><span class="s">&quot;Profile.prof&quot;</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">strip_dirs</span><span class="p">()</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="s">&quot;time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
</pre></div>
</div>
<p>Running this on my box gives the following output:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>Sat Nov  7 17:40:54 2009    Profile.prof

         10000004 function calls in 6.211 CPU seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    3.243    3.243    6.211    6.211 calc_pi.py:7(approx_pi)
 10000000    2.526    0.000    2.526    0.000 calc_pi.py:4(recip_square)
        1    0.442    0.442    0.442    0.442 {range}
        1    0.000    0.000    6.211    6.211 &lt;string&gt;:1(&lt;module&gt;)
        1    0.000    0.000    0.000    0.000 {method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects}
</pre></div>
</div>
<p>This contains the information that the code runs in 6.2 CPU seconds. Note that
the code got slower by 2 seconds because it ran inside the cProfile module. The
table contains the real valuable information.  You might want to check the
Python <a class="reference external" href="http://docs.python.org/library/profile.html">profiling documentation</a>
for the nitty gritty details. The most important columns here are totime (total
time spent in this function <strong>not</strong> counting functions that were called by this
function) and cumtime (total time spent in this function <strong>also</strong> counting the
functions called by this function). Looking at the tottime column, we see that
approximately half the time is spent in approx_pi and the other half is spent
in recip_square. Also half a second is spent in range … of course we should
have used xrange for such a big iteration. And in fact, just changing range to
xrange makes the code run in 5.8 seconds.</p>
<p>We could optimize a lot in the pure Python version, but since we are interested
in Cython, let’s move forward and bring this module to Cython. We would do this
anyway at some time to get the loop run faster. Here is our first Cython version:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c"># encoding: utf-8</span>
<span class="c"># cython: profile=True</span>
<span class="c"># filename: calc_pi.pyx</span>

<span class="k">def</span> <span class="nf">recip_square</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="n">i</span><span class="o">**</span><span class="mf">2</span>

<span class="k">def</span> <span class="nf">approx_pi</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="o">=</span><span class="mf">10000000</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">val</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">k</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mf">1</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">+=</span> <span class="n">recip_square</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">6</span> <span class="o">*</span> <span class="n">val</span><span class="p">)</span><span class="o">**.</span><span class="mf">5</span>
</pre></div>
</div>
<p>Note the second line: We have to tell Cython that profiling should be enabled.
This makes the Cython code slightly slower, but without this we would not get
meaningful output from the cProfile module. The rest of the code is mostly
unchanged, I only typed some variables which will likely speed things up a bit.</p>
<p>We also need to modify our profiling script to import the Cython module directly.
Here is the complete version adding the import of the pyximport module:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c">#!/usr/bin/env python</span>
<span class="c"># encoding: utf-8</span>
<span class="c"># filename: profile.py</span>

<span class="k">import</span> <span class="nn">pstats</span><span class="o">,</span> <span class="nn">cProfile</span>

<span class="k">import</span> <span class="nn">pyximport</span>
<span class="n">pyximport</span><span class="o">.</span><span class="n">install</span><span class="p">()</span>

<span class="k">import</span> <span class="nn">calc_pi</span>

<span class="n">cProfile</span><span class="o">.</span><span class="n">runctx</span><span class="p">(</span><span class="s">&quot;calc_pi.approx_pi()&quot;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="s">&quot;Profile.prof&quot;</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">pstats</span><span class="o">.</span><span class="n">Stats</span><span class="p">(</span><span class="s">&quot;Profile.prof&quot;</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">strip_dirs</span><span class="p">()</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="s">&quot;time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
</pre></div>
</div>
<p>We only added two lines, the rest stays completely the same. Alternatively, we could also
manually compile our code into an extension; we wouldn’t need to change the
profile script then at all. The script now outputs the following:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>Sat Nov  7 18:02:33 2009    Profile.prof

         10000004 function calls in 4.406 CPU seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    3.305    3.305    4.406    4.406 calc_pi.pyx:7(approx_pi)
 10000000    1.101    0.000    1.101    0.000 calc_pi.pyx:4(recip_square)
        1    0.000    0.000    4.406    4.406 {calc_pi.approx_pi}
        1    0.000    0.000    4.406    4.406 &lt;string&gt;:1(&lt;module&gt;)
        1    0.000    0.000    0.000    0.000 {method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects}
</pre></div>
</div>
<p>We gained 1.8 seconds. Not too shabby. Comparing the output to the previous, we
see that recip_square function got faster while the approx_pi function has not
changed a lot. Let’s concentrate on the recip_square function a bit more. First
note, that this function is not to be called from code outside of our module;
so it would be wise to turn it into a cdef to reduce call overhead. We should
also get rid of the power operator: it is turned into a pow(i,2) function call by
Cython, but we could instead just write i*i which could be faster. The
whole function is also a good candidate for inlining.  Let’s look at the
necessary changes for these ideas:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c"># encoding: utf-8</span>
<span class="c"># cython: profile=True</span>
<span class="c"># filename: calc_pi.pyx</span>

<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">double</span> <span class="nf">recip_square</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">approx_pi</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="o">=</span><span class="mf">10000000</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">val</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">k</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mf">1</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">+=</span> <span class="n">recip_square</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">6</span> <span class="o">*</span> <span class="n">val</span><span class="p">)</span><span class="o">**.</span><span class="mf">5</span>
</pre></div>
</div>
<p>Now running the profile script yields:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>Sat Nov  7 18:10:11 2009    Profile.prof

         10000004 function calls in 2.622 CPU seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    1.782    1.782    2.622    2.622 calc_pi.pyx:7(approx_pi)
 10000000    0.840    0.000    0.840    0.000 calc_pi.pyx:4(recip_square)
        1    0.000    0.000    2.622    2.622 {calc_pi.approx_pi}
        1    0.000    0.000    2.622    2.622 &lt;string&gt;:1(&lt;module&gt;)
        1    0.000    0.000    0.000    0.000 {method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects}
</pre></div>
</div>
<p>That bought us another 1.8 seconds. Not the dramatic change we could have
expected. And why is recip_square still in this table; it is supposed to be
inlined, isn’t it?  The reason for this is that Cython still generates profiling code
even if the function call is eliminated. Let’s tell it to not
profile recip_square any more; we couldn’t get the function to be much faster anyway:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c"># encoding: utf-8</span>
<span class="c"># cython: profile=True</span>
<span class="c"># filename: calc_pi.pyx</span>

<span class="k">cimport</span> <span class="nn">cython</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">profile</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">double</span> <span class="nf">recip_square</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">approx_pi</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="o">=</span><span class="mf">10000000</span><span class="p">):</span>
    <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">val</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">k</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mf">1</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">+=</span> <span class="n">recip_square</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">6</span> <span class="o">*</span> <span class="n">val</span><span class="p">)</span><span class="o">**.</span><span class="mf">5</span>
</pre></div>
</div>
<p>Running this shows an interesting result:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>Sat Nov  7 18:15:02 2009    Profile.prof

         4 function calls in 0.089 CPU seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.089    0.089    0.089    0.089 calc_pi.pyx:10(approx_pi)
        1    0.000    0.000    0.089    0.089 {calc_pi.approx_pi}
        1    0.000    0.000    0.089    0.089 &lt;string&gt;:1(&lt;module&gt;)
        1    0.000    0.000    0.000    0.000 {method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects}
</pre></div>
</div>
<p>First note the tremendous speed gain: this version only takes 1/50 of the time
of our first Cython version. Also note that recip_square has vanished from the
table like we wanted. But the most peculiar and import change is that
approx_pi also got much faster. This is a problem with all profiling: calling a
function in a profile run adds a certain overhead to the function call. This
overhead is <strong>not</strong> added to the time spent in the called function, but to the
time spent in the <strong>calling</strong> function. In this example, approx_pi didn’t need 2.622
seconds in the last run; but it called recip_square 10000000 times, each time taking a
little to set up profiling for it. This adds up to the massive time loss of
around 2.6 seconds. Having disabled profiling for the often called function now
reveals realistic timings for approx_pi; we could continue optimizing it now if
needed.</p>
<p>This concludes this profiling tutorial. There is still some room for
improvement in this code. We could try to replace the power operator in
approx_pi with a call to sqrt from the C stdlib; but this is not necessarily
faster than calling pow(x,0.5).</p>
<p>Even so, the result we achieved here is quite satisfactory: we came up with a
solution that is much faster then our original Python version while retaining
functionality and readability.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index_ko.html">
              <img class="logo" src="../../_static/cythonlogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index_ko.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">프로파일링</a><ul>
<li><a class="reference internal" href="#cython-profiling-basics">Cython Profiling Basics</a><ul>
<li><a class="reference internal" href="#enabling-profiling-for-a-complete-source-file">Enabling profiling for a complete source file</a></li>
<li><a class="reference internal" href="#disabling-profiling-function-wise">Disabling profiling function wise</a></li>
<li><a class="reference internal" href="#enabling-line-tracing">Enabling line tracing</a></li>
<li><a class="reference internal" href="#enabling-coverage-analysis">Enabling coverage analysis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#profiling-tutorial">Profiling Tutorial</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="caveats_ko.html"
                        title="previous chapter">주의사항</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="strings_ko.html"
                        title="next chapter">유니코드와 문자열 전달</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/src/tutorial/profiling_tutorial_ko.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="strings_ko.html" title="유니코드와 문자열 전달"
             >next</a></li>
        <li class="right" >
          <a href="caveats_ko.html" title="주의사항"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index_ko.html">싸이선(Cython) 0.28a0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index_ko.html" >튜토리얼</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Stefan Behnel, Robert Bradshaw, Dag Sverre Seljebotn, Greg Ewing, William Stein, Gabriel Gellner, et al..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-6139100-3");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>